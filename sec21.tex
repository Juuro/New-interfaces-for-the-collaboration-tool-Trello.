%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Trello API wrapper
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\onehalfspacing
\chapter{Trello API wrapper}\index{Trello}\index{API}\label{apiwrapper}

These scripts fulfill very different tasks, but they have also much in common. For example, almost every script potentially loads single cards. This API wrapper represents Trello in Ruby. This is a kind of translation from Trello to Ruby and vice versa. Additionally, the scripts can now use the functions and, in consequence, they can stay very lightweight and clean. Almost everything that is possible with the Trello API is also possible with this API wrapper. It doesn't cover all features, though, because the API is still in beta phase, so it changes quite quickly.

\begin{figure}
\centering
\includegraphics[width=\textwidth]{figures/api-wrapper}
\caption{Connections between Trello, the API wrapper, and the actual features. \cite{ruby:icon}\cite{html:logo}\cite{joomla}\cite{google} }
\label{fig: api-wrapper}
\end{figure}

The API wrapper also has functions to pre-process data for Ruby. From a developer's point of view, Trello is all about cards. Cards are the only things in Trello with real data, not just meta data. So if the task is to get a board from the API\index{API}, it means to get the cards of the board. Although the developer won't be able to read out all information, there is an API call to get all cards belonging in a specific board. So the API wrapper has to execute the API call for a single card to cumulate all the information about all the cards of the board. This is the function of the API wrapper, to keep the actual script clean. So the developer can work with the data and doesn't have to worry about determining it.

\todo{So stehen lassen?} The API wrapper is meant to perform all API calls which are required by the scripts. None of the API calls should be performed by the scripts that use the bucket.


\section{Command Line Interface}\nomenclature{CLI}{Command Line Interface}\index{CLI}\index{Command-Line Interface}\label{cli}
Almost every script needs some information. The information which every scripts needs, is the key and token of the user whose account is supposed to be used to access Trello. The scripts have to know which cards, lists, and boards they have to look at. Therefore, this information has to be passed on to the scripts, too. At first we set this information at the top of the script. But it became obvious that it is very unpractical to hard code this in each script. This way, it would be impossible to use the same Ruby file with several Trello accounts. For every Trello account, the user has to generate a dedicated file. The solution for this problem is a command-line interface (CLI). With a CLI, the user can pass on information to the script in a predefined format, so the script knows exactly what to do. For every other call, the user can specify different information for the same script.

The Ruby class OptionParser\cite{ruby:optionparser} provides easy customisable command-line option analysis. The developer is able to specify their own options for each script. For this purpose, a dedicated class is used. 
In order to let the actual script \emph{know} about the CLI arguments, the developer has to require the respective CLI class with the command-line option definitions.

\begin{lstlisting}[aboveskip=1\baselineskip, style=bash, caption=Example usage of a script with CLI., label=listing004]
ruby html.rb -c 4ffd78a2c063afeb066408b8
\end{lstlisting}

An example usage of a script with CLI would look like Listing \ref{listing004}. The \texttt{-c} is a command-line option. If there is a string behind the option, like in this case, the string is a so called \emph{argument}. But there are command-line options which stand by themselves. These are called \emph{flags}, which are for polar decisions only.

\begin{lstlisting}[aboveskip=1\baselineskip, caption=Definition of a command-line option, label=listing002]
# Trello list(s)
opts.on("-l", "--lists x,y,z", Array, "Ids of one or more Trello lists.") do |lists| (*@\label{line001}@*)
	options.lists = lists
end
\end{lstlisting}

Listing \ref{listing002} shows the definition of the option \texttt{-l} for passing one or more IDs of lists to a script. In Line \ref{line001} the word \lstinline{Array} casts the list argument to an Array object.

OptionParse provides an automated help option. If the user types 
\begin{center}
\texttt{ruby script.rb -h} 
\end{center}
they get the explanation the developer wrote in the CLI class for this script with all possible options. This list is automatically generated by the definitions of the command-line options like in Listing \ref{listing002}. It works with \texttt{-help} and \texttt{--help} instead of \texttt{-h}, too.

\begin{lstlisting}[aboveskip=1\baselineskip, style=bash, caption=Output of the \texttt{-h} option., label=listing003]
Usage: ical.rb [options]
Select the input cards with -c, -l, -b or -a

Specific options:
 -a, --[no-]all         Set this if all due dates of all cards of all boards this user can see shall be used.
 -l, --lists x,y,z      Ids of one or more Trello lists.
 -b, --boards x,y,z     Ids of one or more Trello boards.
 -o, --organizations x,y,z Ids of one or more Trello organizations.
 -c, --cards x,y,z      Ids of one or more Trello cards.
 -k MANDATORY, --key    Your Trello key.
 -t MANDATORY, --token  The Trello token.
\end{lstlisting}

Listing \ref{listing003} shows the Output of \texttt{ruby ical.rb -h}. 
These are the basic CLI commands used by every script. For some scripts there are additional commands, which are explained in their respective sections.

\section{Methods}
The API calls which are wrapped by the following methods need a private key and a token to access content in private boards. Thus, private key and token need not be sent to each method, it will be initialized in each script as global variables. The variable for the private key is alled \lstinline{$key} and the one for the token is called \lstinline{$token}.

\subsection{Handling of date and time}
Content in Trello may have set dates. These dates are represented by the Trello API as an ISO\nomenclature{ISO}{International Organization for Standardization} 8601\index{ISO!8601}\footnote{More information about ISO 8601 on the website of the International Organization for Standardization: \url{http://www.iso.org/iso/home/store/catalogue_tc/catalogue_detail.htm?csnumber=40874}. The RFC 3339 is a profile of ISO 8601: \url{http://www.ietf.org/rfc/rfc3339.txt}} formatted string. The timezone\index{timezone} of the date is UTC\nomenclature{UTC}{Universal Time Coordinated}. To ensure that the correct time is always displayed, the date has to be adapted to local time. 

\subsubsection{getDate(date, format='de')}
\begin{lstlisting}[aboveskip=1\baselineskip, caption=\lstinline{getDate()}, label=listing044]
def getDate(date, format='de')
	fdate = Time.iso8601(date).getlocal (*@ \label{line045} @*)
	
	if format=='de'
		return fdate.strftime('%d.%m.%Y %H:%M:%S')
	elsif format=='us'
		return fdate.strftime('%m/%d/%Y %I.%M.%S %P')
	elsif format=='joomla'
		return fdate.strftime('%Y-%m-%d %H:%M:%S')
	elsif format=='ical'
		return fdate.strftime('%Y%m%dT%H%M%S')
	elsif format=='year'
		return fdate.strftime('%Y')
	elsif format=='iso8601'
		return fdate.iso8601
	end
end
\end{lstlisting}

In line \ref{line045} of listing \ref{listing044} the given date string in ISO 8601 format is parsed to a Ruby Time object. The \lstinline{getlocal} is the important part here. This function of the Time class determines the server's time zone and readjusts the time accordingly. This method respects the daylight saving time in several time zones, too. For this function working as intended it is important that the correct time zone is set on the used server. 

The \lstinline{getDate()} method additionaly converts the date to othe formats. 

\subsection{Collect data from Trello}
The several objects in Trello such as cards, lists and boards are accessed by these scripts regularly. To keep the actual scripts clean the API wrapper includes methods to determine and process the information of these onjects.

\subsubsection{getBoardsByMember(memberId)}
\begin{lstlisting}[aboveskip=1\baselineskip, caption=\lstinline{getBoardsByMember()}, label=listing045]
def getBoardsByMember(memberId)
	boards = RestClient.get("https://api.trello.com/1/members/"+memberId+"/boards?key="+$key+"&token="+$token+"&filter=open")
	boards = JSON.parse(boards)
end
\end{lstlisting}
The method \lstinline{getBoardsByMember()} receives a member id and determines all boards accessible by this Trello account.

\subsubsection{getListsByBoard(boardId)}
\begin{lstlisting}[aboveskip=1\baselineskip, caption= getListsByBoard(), label=listing046]
def getListsByBoard(boardId)
	list = RestClient.get("https://api.trello.com/1/boards/"+boardId+"/lists?key="+$key+"&token="+$token)
	list = JSON.parse(list)	
end
\end{lstlisting}

\subsubsection{getList(listId)}
\begin{lstlisting}[aboveskip=1\baselineskip, caption= getList(), label=listing047]
def getList(listId)
	list = RestClient.get("https://api.trello.com/1/lists/"+listId+"?key="+$key+"&token="+$token)
	list = JSON.parse(list)	
end
\end{lstlisting}

\subsubsection{getSingleCard(cardId)}
\begin{lstlisting}[aboveskip=1\baselineskip, caption=getSingleCard(), label=listing048]
def getSingleCard(cardId)
	card = RestClient.get("https://api.trello.com/1/cards/"+cardId+"?key="+$key+"&token="+$token)
	card = JSON.parse(card)
end
\end{lstlisting}

\subsubsection{getCardsByBoard(boardId)}\begin{lstlisting}[aboveskip=1\baselineskip, caption=getCardsByBoard() label=listing049]
def getCardsByBoard(boardId)
	board = RestClient.get("https://api.trello.com/1/boards/"+boardId+"/cards?key="+$key+"&token="+$token+"&filter=open")
	board = JSON.parse(board)
end
\end{lstlisting}

\subsubsection{getCardsByList(listId)}
\begin{lstlisting}[aboveskip=1\baselineskip, caption=getCardsByList(), label=listing050]
def getCardsByList(listId)
	list = RestClient.get("https://api.trello.com/1/lists/"+listId+"/cards?key="+$key+"&token="+$token+"&filter=open")
	list = JSON.parse(list)
end
\end{lstlisting}

\subsubsection{getCardsAsArray(arrayCardsStd, downloads = true)}
\begin{lstlisting}[aboveskip=1\baselineskip, caption= getCardsAsArray(), label=listing063]
def getCardsAsArray(arrayCardsStd, downloads = true)
	arrayCardsFull = Array.new
	directoryNameAttachments = File.join(Dir.tmpdir, "attachments")
	
	arrayCardsStd.each do |card|
		# export members
		memberArray = Array.new
		card['idMembers'].each do |memberId|
			member = getMember(memberId)
			memberArray << member			
		end
		membersForCard = Hash.new
		membersForCard['members'] = memberArray
		card = card.merge(membersForCard)
		# end export members		
		
		# export checklists
		hasChecklist = getChecklist(card['id']) 
		
		if hasChecklist[0] != nil
			arrayChecklists = Array.new
			hasChecklist.each do |checklist|  
				hashChecklist = Hash.new  
				hashChecklist['id'] = checklist['id']
				hashChecklist['name'] = checklist['name']
				arrayItems = Array.new
				checklist['checkItems'].each do |item|
					hashItem = Hash.new
					hashItem['name'] = item['name']
					if isCompleted(card['id'], item['id'])
						hashItem['completed'] = true
					else
						hashItem['completed'] = false
					end
					hashItem['pos'] = item['pos']
					arrayItems.push(hashItem)
				end
				hashChecklist['items'] = arrayItems
				arrayItems = nil
				arrayChecklists.push(hashChecklist)
				hashChecklist = nil
			end
			
			hashCheckListsForCard = Hash.new
			hashCheckListsForCard['checklists'] = arrayChecklists
			
			card = card.merge(hashCheckListsForCard)
		end
		# end export checklists
		
		# export comments
		if card['badges']['comments'] != 0
			comments = getCardComments(card['id'])
			hashCommentsForCard = Hash.new			
			hashCommentsForCard['commentsContent'] = comments			
			card = card.merge(hashCommentsForCard)
		end
		# end export comments
		
		# export attachments
		if card['badges']['attachments'] != 0
			attachments = getAttachment(card['id'])			
			hashAttachmentsForCard = Hash.new			
			hashAttachmentsForCard['attachments'] = attachments			
			card = card.merge(hashAttachmentsForCard)			
			
			if downloads
				# url runterladen
				attachments.each do |attachment|
					fileDomain = URI.parse(attachment['url']).host
					filePath = attachment['url'].gsub(URI.parse(attachment['url']).scheme+"://"+URI.parse(attachment['url']).host, '')
					fileExtension = File.extname(attachment['url'])
					
					fileName = attachment['id']+File.basename(attachment['url'])
					puts "Downloading \'"+fileName+"\'"
								
					if !Dir.exists?(directoryNameAttachments)
						Dir::mkdir(directoryNameAttachments)
					end
					
					Net::HTTP.start(fileDomain) do |http|
							resp = http.get(filePath)
							open(directoryNameAttachments+"/"+fileName, "wb") do |file|
									file.write(resp.body)
							end
					end      
				end
				# url runterladen
			end       
		end	
		# end export attachments
		
		# export votes
		if card['badges']['votes'] > 0
			reply = RestClient.get(
					'https://api.trello.com/1/cards/'+card['id']+'/membersVoted?key='+$key+'&token='+$token
			)
			members = JSON.parse(reply)
			membersVotedArray = Array.new
			members.each do |member|
				 membersVotedArray.push(member['id'])
			end
			hashMembersVotedForCard = Hash.new			
			hashMembersVotedForCard['membersVoted'] = membersVotedArray
			card = card.merge(hashMembersVotedForCard)	
		end
		# end export votes
		
		arrayCardsFull.push(card)
	end
	
	return arrayCardsFull
end
\end{lstlisting}

\subsection{Further information on a card}

\subsubsection{getCardActions(cardId)}
\begin{lstlisting}[aboveskip=1\baselineskip, caption=getCardActions(), label=listing051]
def getCardActions(cardId)
	actions = RestClient.get("https://api.trello.com/1/cards/"+cardId+"/actions?key="+$key+"&token="+$token)
	actions = JSON.parse(actions)
end
\end{lstlisting}

\subsubsection{getCardComments(cardId)}
\begin{lstlisting}[aboveskip=1\baselineskip, caption= getCardComments(), label=listing052]
def getCardComments(cardId)
	actions = RestClient.get("https://api.trello.com/1/cards/"+cardId+"/actions?filter=commentCard&key="+$key+"&token="+$token)
	actions = JSON.parse(actions)
end
\end{lstlisting}

\subsubsection{cardUpdated(cardId)}
\begin{lstlisting}[aboveskip=1\baselineskip, caption= cardUpdated(), label=listing053]
def cardUpdated(cardId)
	reply = RestClient.get('https://api.trello.com/1/cards/'+cardId+'/actions?filter=updateCard&key='+$key+'&token='+$token)

	updates = JSON.parse(reply.body)
end
\end{lstlisting}

\subsubsection{cardCreated(cardId)}
\begin{lstlisting}[aboveskip=1\baselineskip, caption= cardCreated(), label=listing054]
def cardCreated(cardId)
	reply = RestClient.get('https://api.trello.com/1/cards/'+cardId+'/actions?filter=createCard&key='+$key+'&token='+$token)

	updates = JSON.parse(reply.body)
end
\end{lstlisting}

\subsubsection{isCompleted(cardId, itemId)}
\begin{lstlisting}[aboveskip=1\baselineskip, caption= isCompleted(), label=listing055]
def isCompleted(cardId, itemId)
	completedItems = RestClient.get("https://api.trello.com/1/cards/"+cardId+"/checkitemstates?key="+$key+"&token="+$token)
	completedItems = JSON.parse(completedItems)

	completedItems.each do |item|
		if item['idCheckItem'] == itemId
			return true
		end
	end

	return false
end
\end{lstlisting}

\subsubsection{getChecklist(cardId)}
\begin{lstlisting}[aboveskip=1\baselineskip, caption= getChecklist(), label=listing056]
def getChecklist(cardId)
	checklists = RestClient.get("https://api.trello.com/1/cards/"+cardId+"/checklists?key="+$key+"&token="+$token)
	data = JSON.parse(checklists)

	return data  
end
\end{lstlisting}

\subsubsection{getAttachment(cardId)}
\begin{lstlisting}[aboveskip=1\baselineskip, caption= getAttachment(), label=listing057]
def getAttachment(cardId)
	attachments = RestClient.get("https://api.trello.com/1/cards/"+cardId+"/attachments?key="+$key+"&token="+$token)
	data = JSON.parse(attachments)

	return data
end
\end{lstlisting}

\subsection{Member information}

\subsubsection{getMember(memberId)}
\begin{lstlisting}[aboveskip=1\baselineskip, caption= getMember(), label=listing058]
def getMember(memberId)
	member = RestClient.get("https://api.trello.com/1/members/"+memberId+"?key="+$key+"&token="+$token+"&filter=open")
	member = JSON.parse(member)
end
\end{lstlisting}

\subsubsection{isThisMe(memberId)}
\begin{lstlisting}[aboveskip=1\baselineskip, caption= isThisMe(), label=listing059]
def isThisMe(memberId)
	if getMember('me')['id'] == memberId
		return true
	else
		return false
	end
end
\end{lstlisting}

\subsubsection{getMembersByBoard(boardId)}
\begin{lstlisting}[aboveskip=1\baselineskip, caption= getMembersByBoard(), label=listing060]
def getMembersByBoard(boardId)
	members = RestClient.get("https://api.trello.com/1/boards/"+boardId+"/members?&key="+$key+"&token="+$token)
	members = JSON.parse(members)	
end
\end{lstlisting}

\subsection{Accessing CMS}

\subsubsection{trelloToJoomlaSingle(joomlaArticleId, articles)}
\begin{lstlisting}[aboveskip=1\baselineskip, caption= trelloToJoomlaSingle(), label=listing061]

\end{lstlisting}

\subsubsection{trelloJoomlaSync(cardId, sectionid, catid, joomlaVersion)}
\begin{lstlisting}[aboveskip=1\baselineskip, caption= trelloJoomlaSync(), label=listing062]

\end{lstlisting}