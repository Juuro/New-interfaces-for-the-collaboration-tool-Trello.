%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Diskussion und Ausblick
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Applications}

\section{Export to HTML}\nomenclature{HTML}{Hyper Text Markup Language}\label{html.rb}

Used libraries:
\begin{itemize}
	\item \texttt{erb}
	\item \texttt{json}
	\item \texttt{rest\_client}
	\item \texttt{pp}
	\item \texttt{kramdown}
\end{itemize}

\begin{lstlisting}[aboveskip=1\baselineskip, style=bash, caption=\texttt{html.rb} usage., label=listing026]
ruby html.rb --title TITLE [-c CARDID[,CARDID]] [-l LISTID[,LISTID]] [-b BOARDID[,BOARDID]] [-a] [-t TOKEN] [-k KEY]
\end{lstlisting}

The \texttt{html.rb} script exports the data from one or more cards to an HTML file. The resulting HTML file lists the cards one below another. The order is determined by the order in the command-line argument. If the command-line looks like listing \ref{listing005} the script will at first process the list with the id \texttt{4ffd78ff7f0c71780cc5aa1c}. That means that all cards in the list are in the HTML file and below these the single card with the id \texttt{4ffd78a2c063afeb066408b8}. In addition to the command-line options described in section \ref{cli} the option \texttt{--title} is used. Here the user has to specify a title for the web page. The title will be displayed at the top of the page in \lstinline{<h1>} HTML tags.

\begin{lstlisting}[aboveskip=1\baselineskip, style=bash, caption=Example of a \texttt{html.rb} call., label=listing005]
ruby html.rb -l 4ffd78ff7f0c71780cc5aa1c                 -c 4ffd78a2c063afeb066408b8 --title 'Madness'
\end{lstlisting} 

Each card is displayed with all its information. This includes title, description, members, due date, labels, votes, checklists, comments and attachments.

Trello itself distinguishes between photos and other attachments. Normal attachments are linked under the description. Photos are embedded in the HTML code as thumbnails. Trello detects JPEG, GIF and PNG files as pictures and displays them as thumbnails. In addition to these formats the resulting HTML file displays TIFF, PSD, BMP and JPEG2000 as thumbnails, too. All modern Browsers support these formats.

The \texttt{html.rb} script generates static HTML. Of course the goal could also reached with a dynamic solution with PHP or Ruby on Rails. But the upside is that the user of the respective website doesn't have to wait for the webserver. Dynamic websites are mostly fast in the meantime, but with static HTML files the developer is on the safe side. This approach pays off especially if the data to be displayed doesn't change every minute. The server doesn't have to generate the whole data with every visit. It just to send the static HTML files.

\subsection{Markdown}\index{Markdown}
Markdown is a small lightweight plain text formatting snytax, designed by John Gruber. It's designed for the use with blogs and CMS. In these cases HTML is often too much. Markdown represents most of the features of HTML that are needed for writing. The designer of Markdown, had the goal that a text, written in Markdown, is still easy to read. John Gruber provides a software tool, written in the Perl programming language, that converts the Markdown formatted text to valid HTML. \cite{markdown}

\begin{lstlisting}[aboveskip=1\baselineskip, style=bash, caption=Example for a text written in Markdown., label=listing006]
### iCloud:(*@ \label{line002} @*)

1.   Shared Photo Streams Now you can *share* just the **photos** you want, with just the people you choose. (*@ \label{line003} @*)
2.   Reminder

------------------------------- (*@ \label{line004} @*)

Here is an example of AppleScript:

    tell application "Foo" (*@ \label{line005} @*)
        beep
    end tell

![Apple logo](http://upload.wikimedia.org/wikipedia/commons/f/fa/Apple_logo_black.svg "Apple logo") (*@ \label{line006} @*)
\end{lstlisting}


\begin{lstlisting}[aboveskip=1\baselineskip, style=html, caption=Listing \ref{listing006} converted to HTML., label=listing007]
<h3>iCloud:</h3>

<ol>
	<li>Shared Photo Streams Now you can <em>share</em> just the <strong>photos</strong> you want, with just the people you choose.</li>
	<li>Reminder</li>
</ol>

<hr>

<p>Here is an example of AppleScript:</p>

<pre>
	<code>tell application "Foo"
	beep
	end tell</code>
</pre>

<p><img alt="Apple logo" title="Apple logo" src="http://upload.wikimedia.org/wikipedia/commons/f/fa/Apple_logo_black.svg"></p>
\end{lstlisting} 

Listing \ref{listing006} shows a small example of Markdown. The \lstinline{###} in line \ref{line002} is a header equal to \lstinline{<h3>} in HTML. The first list item of the ordered list in line \ref{line003} contains italic and bold words. In line \ref{line004} there is a horizontal line. After a normal line of text a code block starts in line \ref{line005}. At the end in line \ref{line006} there is a picture with \lstinline{title} and \lstinline{alt} texts. After the conversion it looks like listing \ref{listing007} in HTML. The appearance, of course, depends on the used CSS on the respective websites. The appearance in Trello is as shown in figure \ref{fig:markdown-result}.

\begin{figure}[htb]
\centering
\includegraphics[scale=0.6]{figures/markdown-result}
\caption{The browser view of the HTML converted from the Markdown in listing \ref{listing006}}
\label{fig:markdown-result}
\end{figure}

Meanwhile Markdown has become quite popular. Many blogging platforms support it, at least there are Markdown plug-ins for most platforms. Trello supports it in the description of cards. In the unlikely case that markdown reaches its limits inline HTML can be used. The only restriction is, that HTML block-level-elements have to be separated to the previous and following Markdwon blocks.

\subsubsection{kramdown}

In order to convert Markdown to HTML the gem kramdown is used. Figure \ref{fig:kramdown} describes the convert options of kramdown. It converts HTML and Markdown to LaTeX, PDF and a special kramdown format, too. The kramdown format is an extended Markdown syntax. Like input formats it accepts HTML and kramdown besides standard Markdown. \cite{kramdown} These additional features of kramdown might be useful for future approaches. To generate lists bibliographies for scripts, papers or books.

\begin{figure}[htb]
\centering
\includegraphics[width=\textwidth]{figures/kramdown}
\caption{Overview about kramdowns converting options. \cite{kramdown}}
\label{fig:kramdown}
\end{figure}

\subsection{Twitter Bootstrap Framework}\index{Twitter}\index{Bootstrap}
In 2011 Twitter released Bootstrap\footnote{Blog post form the lead developer about the launch of Twitter Bootstrap: \url{https://dev.twitter.com/blog/bootstrap-twitter}}. Bootstrap is a collection of methods and scripts for creating front-ends of websites. It contains templates for site structuring, tables, text, buttons, menus, forms, lists and some other often used elements of websites. Additionaly some functions are supported by JavaScript\index{JavaScript}. Bootstrap is written in HTML\index{HTML}, JavaScript, CSS\index{CSS} and LESS\index{LESS}. LESS is a dynamic style sheet language and extends CSS. This enables the use of variables, functions, nested selectors and operators.\cite{less} Bootstrap is completely free of charge and under open source licence. \cite{bootstrap}

Bootstrap\index{Bootstrap} evolved at Twitter\index{Twitter} during work on several projects with different libraries. The projects became inconsistent and a high administrative effort was needed. Some developers at Twitter led by Mark Otto worked on o tool to document and share common designs within the company. Twitter determined that this toolkit could be more than an intern helper tool. So they equipped it with all the common function which are needed for modern web development and released it on GitHub. \cite{markotto}

\subsection{HTML5}\index{HTML!5}
Twitter Bootstrap supports HTML5. HTML is the markup language for displaying content in a web browser. HTML5 is the latest revision of the HTML standard. It's an open format developed by the World Wide Web Consortium (W3C)\index{World Wide Web Consortium}\index{W3C}. HTML5 has been a working draft since 2008. In 2011 the HTML Working Group at W3C advanced HTML5 to Last Call. At the moment HTML communities all over the world are asked to confirm the standard.  It is estimated that HTML5 will reach W3C Recommendation by 2014.\cite{html:lastcall} Although it is not yet finished, it is already widely used.

Before HTML5  there were two popular standards: HTML4\index{HTML!4} and XHTML1\index{XHTML}\nomenclature{XHTML}{Extensible Hyper Text Markup Language}. XHTML1 defines a XML\index{XML} serialisation for HTML4. With HTML5 there is only one language called HTML. This language can be written in HTML syntax and XML syntax. 
\cite{html:5differences} The W3C realised the importance of smartphones in the future early on. They guided the development of HTML5 with the consideration of being able to run on low-powered devices. The market share of HTML5 enabled devices is still rising. \cite{smartphonesales} Smartphone sales even beat PC sales in 2012. Thus, it is becoming increasingly important that web apps work well on small devices. To ensure this HTML5 is used. The foundation created here can therefore be used as a basis for the future.

HTML5 introduces several new elements. Some of these are used in \texttt{html.rb}. At first there is the \lstinline{<header>} element. A header is an area at the top of a web page. It is used for navigational aids, logos or a search bar. \cite{html5:header} At the bottom is the \lstinline{<footer>} element. The \lstinline{<footer>} element can be used as a side wide footer and as a footer of sections. \cite{html5:footer} Here it is just used as side wide footer as preparation for data like licencing information, imprint and information about the author. The cards are enclosed in \lstinline{<article>} elements. Every single card is represented as an \lstinline{<article>} element. This makes sense because typically a card is an article, especially if the user would like the card to be displayed on a web page. The W3C requires an \lstinline{<article>} element to be self-contained. \cite{html5:article} A card is a collection of information which is ordered by the several types of data. 

This foundation of generating HTML out of Trello can be used in various ways. It's predestinated for website with recurring kinds of information. Every business card style web page can definitely be managed with this script. Very small websites right through to whole blogs can build on it.

\subsection{Templating with ERB}\index{ERB}\index{Templating}\nomenclature{ERB}{embedded Ruby}
Every card is embedded in the same HTML structure. Templates specify this HTML without the actual data. Instead of the data there is just a wildcard and a few control structures. Templating systems are used to organise the source code in operationally-distinct layers. The design is completely handled in the template file. But the control structure is partially in the template file, too. Template engines are however unsuitable for a real separation of the data models and the logic components. For this porpose additional concepts such as Model View Controller are required (MVC)\nomenclature{MVC}{Model View Controller}.

ERB is a templating system for Ruby. It's part of the Ruby standard library. ERB accepts every string as a template, no matter whether it is stored in a file, a database or some other kind of storage. ERB is mainly used for generating HTML files. It is also able to generate any other kind of structured text, like RSS\index{RSS}\nomenclature{RSS}{Really Simple Syndication} feeds and XML\index{XML}. \cite{erb:introduction} \cite{erb:docu}

While generating the HTML ERB copies the plain text parts of the template file directly to the resulting document.  The parts which ERB has to process are marked with certain tags listed in listing \ref{listing011}
\begin{lstlisting}[aboveskip=1\baselineskip, style=bash, caption=Recognised tags in ERB., label=listing011]
<% Ruby code -- inline with output %>
<%= Ruby expression -- replace with result %>
<%# comment -- ignored -- useful in testing %>
% a line of Ruby code -- treated as <% line %> 
%% replaced with % if first thing on a line and % processing is used
<%% or %%> -- replace with <% or %> respectively
\end{lstlisting}
Only the first two tags are used here. The optimum would be if only \lstinline{<%= Ruby expression -- replace with result %>} would be used. As this would imply that there are no control structures in the template file, just wildcards for data.

A real example of an ERB template is listing \ref{listing012}.

\begin{lstlisting}[aboveskip=1\baselineskip, caption=Ruby method in ERB template., label=listing012]
<small><%= getDate(card['due'], format='de') %></small>
\end{lstlisting}

A Ruby method is used as wildcard here. When processing the template file the method will be executed with the given variables and the result will be copied into the HTML file. But there are control structures, too. The block around the line in listing \ref{listing012} is shown in listing \ref{listing013}

\begin{lstlisting}[aboveskip=1\baselineskip, caption=Ruby method in ERB template., label=listing013]
<% if card['due'] %>
	<small><%= getDate(card['due'], format='de') %></small>
<% end %>
\end{lstlisting}

The \lstinline{if} construct is embedded with the \lstinline{<% ... %>} tag for ERB. This is because it's not a wildcard which is replaced with actual content. This tag is just for control structures.

The alternative to using a templating system is to write the HTML at the same time and in the same file when the data is processed. This would result in a very confusing file which produces equally confusing HTML code. If the developer made sure that the HTML code is well-structured the source code in the script would look even messier. That's because character escape codes like \lstinline{\t} and \lstinline{\n} have to be inserted manually in the source code. Otherwise the templating system takes over this task. An example of such a confusing mixing of HTML, character escape codes and Ruby is shown in \ref{listing014}.

\begin{lstlisting}[aboveskip=1\baselineskip, caption=Generating HTML without a templating engine., label=listing014]
htmlSite << "</strong></span></p>
	\t\t\t\t<div style=\"text-align: left; padding-left: 5px;\"><span style=\"font-size: xx-small;\">"
htmlSite << description		
htmlSite << "</span></div>
	\t\t\t\t<div style=\"text-align: left;\"><span style=\"font-weight: normal; font-size: small;\"> 
	\t\t\t\t\t\t<ul>"
if element.attachments != []
	attachments.each do |attachment|
		name = attachment.name
		url = attachment.url
		htmlSite << "\t\t\t\t\t\t\t\t<li><a href=\""
		htmlSite << url
		htmlSite << "\">"
		htmlSite << name
		htmlSite << "<a/></li>"
	end	
end	
\end{lstlisting}

To represent the list of cards with the title in Ruby there is the Ruby class \texttt{webpage}. It is defined in listing \ref{listing015}.

\begin{lstlisting}[aboveskip=1\baselineskip, caption=Generating HTML without a templating engine., label=listing015]
class Webpage
  def initialize( title )
    @title = title

    @cards = [ ]
  end

  def add_card( card )
    @cards << card
  end

  def get_binding
    binding
  end
end
\end{lstlisting}

There are three methods. The \lstinline{initialize( title )} method generates the actual instance of the class. The instances modeled according to this method contain the given title and an empty array for the cards. The \lstinline{add_card( card )} method simply adds a new card to the \lstinline{@cards} array. The last method is \lstinline{get_binding}. It generates a \lstinline{Binding} object of the current local variables.

\begin{lstlisting}[aboveskip=1\baselineskip, caption=Generating HTML with ERB., label=listing016]
templateFile = File.open("templateHtml.html.erb", "rb")(*@ \label{line007} @*)
template = templateFile.read

rhtml = ERB.new(template)(*@ \label{line008} @*)

webpage = Webpage.new( @htmlTitle )(*@ \label{line009} @*)

cardsFull.each do |card|(*@ \label{line010} @*)
  webpage.add_card(card)
end

html = rhtml.result(webpage.get_binding)(*@ \label{line011} @*)

fileHtml = File.new("index.html", "w+")(*@ \label{line012} @*)
fileHtml.puts html
fileHtml.close()
\end{lstlisting}

In listing \ref{listing016} the template data is set up. At first in line \ref{line007} the template file is opened, in the next line read and saved in the \lstinline{template} variable. So the template is saved as string in \lstinline{template}. In line \ref{line008} with \lstinline{rhtml} an instance of ERB is created. After that in line \ref{line009} the \lstinline{Webpage} class is used. One instance with the given title is generated. In line \ref{line010} each card is added to the instance of \lstinline{Webpage}. Finally in line \ref{line011} the \lstinline{Binding} object of \lstinline{webpage} is created. With the ERB method \lstinline{result} the data in the \lstinline{Binding} object and the template come together. This is the step where the wildcards in the template file are filled with the actual data of the \lstinline{Binding} object. The resulting HTML code is saved in the string variable \lstinline{html} and \lstinline{html}, is saved to the file \texttt{index.html} in line \ref{line012}. 

\section{Synchronisation Google Calendar}\index{Google!Calendar}
Used libraries:
\begin{itemize}
	\item \texttt{erb}
	\item \texttt{json}
	\item \texttt{rest\_client}
	\item \texttt{pp}
	\item \texttt{google/api\_client}
\end{itemize}

Usage:
\begin{lstlisting}[aboveskip=1\baselineskip, style=bash, caption=\texttt{gcal.rb} usage., label=listing025]
ruby gcal.rb [-c CARDID[,CARDID]] [-l LISTID[,LISTID]] [-b BOARDID[,BOARDID]] [-a] [-t TOKEN] [-k KEY]
\end{lstlisting}

Google Calendar is a free web service by Google for time-management. The service can be enabled in several calendar applications such as Apple Calendar (it was called iCal prior to Mac OS X 10.8) and Microsoft Outlook. Even all the important mobile operating systems support it. Google Calendar is one of the most popular calendar web services. One advantage over other suppliers is the excellent integration with all the other Google services, most of which are also very popular.

\subsection{Google Calendar API}
Google provides an API to access Calendar. There is even an API wrapper for Ruby made by Google. But either it contains many bugs or the documentation is poorly written. Some parameters the documentation says are able to send an API call at aren't actually able to do so. Google grants normal developers a courtesy limit of 10,000 requests per day. Developers who need more requests per day for their application have to negotiate with Google and to contract into a higher request rate.

\begin{lstlisting}[aboveskip=1\baselineskip, caption=Initialisation of the Google Calendar API connection., label=listing017]
client = Google::APIClient.new
client.authorization.client_id = ' '
client.authorization.client_secret = ' '
client.authorization.scope = 'https://www.googleapis.com/auth/calendar'
client.authorization.refresh_token = ' '
client.authorization.access_token = ' '

result = client.authorization.fetch_access_token!
client.authorization.access_token = result['access_token']

service = client.discovered_api('calendar', 'v3')
\end{lstlisting}

Authentication with Google is much more complicated than with Trello. Listing \ref{listing017} shows the initialisation of the Google Calendar API connection. At first the project has to be registered in the Google APIs Console. \cite{google:apisconsole} There the developer can get the \lstinline{client_id} and the \lstinline{client_secret}. The \lstinline{scope} depends on the Google API the developer wants to use. Here it is \texttt{https://www.googleapis.com/auth/calendar}. \cite{google:apiscope} To get the \lstinline{access_token} this URL must be called: 
\begin{center}
\lstinline{https://accounts.google.com/o/oauth2/auth?scope=https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fcalendar&redirect_uri=https%3A%2F%2Foauth2-login-demo.appspot.com%2Fcode&response_type=code&client_id=CLIENTID.apps.googleusercontent.com&access_type=offline}
\end{center}

If the request succeeds the response is as noted in listing \ref{listing018}.

\begin{lstlisting}[aboveskip=1\baselineskip, caption=Response of the token request., label=listing018]
{
  "access_token":"1/fFAGRNJru1FTz70BzhT3Zg",
  "expires_in":3920,
  "token_type":"Bearer",
  "refresh_token":"1/xEoDL4iW3cxlI7yDbSRFYNG01kVKM2C-259HOF2aQbI"
}
\end{lstlisting}

The access token is the actual important value. But it expires after about an hour typically. If it is used after the expiration date the API will respond with an error. beacuse of that it's important to store the refresh token. Otherwise, the user has to enter his Google login data every time an access token expires. If the application looses the refresh token, the API calls will no longer work. No new access tokens can be generated. The user, or in this case the developer, has to obtain a refresh token manually again. \cite{google:calapi} Unfornately, how long the refresh tokens are valid is unknown.

\subsection{Synchronisation}
For the synchronisation to Google Calendar only cards with a due dated are considered. At first the script instructs the API wrapper to get all cards. Sadly the Trello API provides no filter method to get only the cards with a due date. The next step is to check if the cards have due dates. If a card has a due date the script checks if this card is already added as an event in Google Calendar. To do so the Google library looks after this card on the basis of its id. If it's not already in Google Calendar the script has to add a new event to Google Calendar.

\begin{lstlisting}[aboveskip=1\baselineskip, caption=Adding a new event to Google Calendar., label=listing022]
event = { (*@ \label{line013} @*)
	'summary' => card['name'],
	'description' => card['desc'],
	'location' => card['id'],
	'start' => {
		'dateTime' => getDate(card['due'], format='iso8601'),
		'timeZone' => 'Europe/Berlin'
	},
	'end' => {
		'dateTime' => getDate(card['due'], format='iso8601'),
		'timeZone' => 'Europe/Berlin'
	}
} (*@ \label{line014} @*)

insertevent = client.execute(:api_method => service.events.insert, (*@ \label{line015} @*)
								:parameters => {'calendarId' => 'primary'}, (*@ \label{line016} @*)
								:body => JSON.generate(event),
								:headers => {'Content-Type' => 'application/json'})
\end{lstlisting}

At first a new \lstinline{event} object has to be created. That happens in listing \ref{listing022} in lines \ref{line013} to \ref{line014}. A hash is used for that. The received information about a card from Trello is stored in a hash. So to get the information \lstinline{card['KEYWORD']} is used, where \lstinline{KEYWORD} stands for the respective name of the cards field that is needed. In the location field of an event the script stores the card id. That's not exactly the correct kind of data to put in a location field. But to determine if a card is already represented as an event in Google Calender the script has to use any unique identifier. Since there is no location for Trello cards anyway, the location field can be used. Sadly Google doesn't provide any \emph{hidden} fields which developers can use for such purposes.

From line \ref{line015} is where the actual request happens. The \lstinline{service.events.insert} tells the Google API which method the developer wants to adress. \cite{google:calapi} In this case it's the method to insert a new event to an existing calendar. In line \ref{line016} the developer has to specify the id of the calendar in which the new event should apper. Clearly \texttt{primary} is not an id. \texttt{primary} stands for the primary calendar. In Google Calendar the user can create several calendars for different purposes. One for work, one for private stuff and so forth. So \texttt{primary} is a valid value, too. In the following line the body is being sent. To do that the \lstinline{event} object created before has to be converted to a JSON string. This is achieved by the \lstinline{generate} method of the JSON class. \cite{json:docu} In the last line of listing \ref{listing022} the Google API is told that the body of this request is formatted as JSON.

If the event is already inserted in the calendar the script checks if the card's summary, description or due date have changed since the last synchronisation to Google Calendar. But before it checks back if this event really is the representation of the actual card. The Google API provides no method to search for events with a special location. So it isn't possible to search in the location of an event. The script looks in all fields of an event for the id of the corresponding Trello card. To ensure that the currently handled card is the same the currently handled event is the representation for, the script compares the location field of the event and the card id. If the comparison matches it runs almost the same code as in listing \ref{listing022}. But this time the Google Calendar API method which is used for updating the event is called \lstinline{service.events.update}. 

The third possible scenario is an orphaned event in Google Calendar. If a user in Trello removes the due date of a card or the card itself, the event in Google Calendar is no longer valid. To solve this problem the script loads all cards with due dates and all events from Google Calendar. All cardids are saved in an array and all location field entries in another. Now the array with the card ids from Trello is subtracted from the array with the location fields. The resulting array contains just events which don't have acorresponding card with a due date in Trello. After that the script checks if the remaining location field entries are in the format of Trello card ids. But the only indicators that can be used are the length of the string – a Trelloc ard id has 24 characters – and if it contains only numbers and letters. TBut there's a problem with this approach. If there are other events which are not inserted by this script which have accidently location fields with 24 characters containing only numbers and letters, they will be deleted. It's not very likely that this happens. Names of cities or other typical used date in the location field don't have the length of 24 characters. GPS positions contain dots and are shorter, too. But the possibility of a match exists. The solution would be to use a dedicated calendar only for the use with this script. Or to be very careful with adding new events manually. Of course it's possible to enable this function completely. But in this case there will remain in Trello delted cards as orphaned events in Google Calendar. They have to be deleted manually.

\section{Export to iCalendar}\index{iCalendar}

Used libraries:
\begin{itemize}
	\item \texttt{icalendar}
	\item \texttt{date}
	\item \texttt{json}
	\item \texttt{rest\_client}
	\item \texttt{pp}
\end{itemize}

Usage:
\begin{lstlisting}[aboveskip=1\baselineskip, style=bash, caption=\texttt{ical.rb} usage., label=listing023]
ruby ical.rb [-c CARDID[,CARDID]] [-l LISTID[,LISTID]] [-b BOARDID[,BOARDID]] [-a] [-t TOKEN] [-k KEY]
\end{lstlisting}

iCalendar is a popular format to exchange calendar data of all sorts. It's built on the prior vCalendar standard released 1996 by the Internet Mail Consortium. \cite{vcalendar} Because of that some object name begin with a V. Originally it was introduced in 1998 by the Internet Engineering Task Force Calendaring and Scheduling Working Group in RFC 2445. \cite{rfc:2445} Today, the actual specification is RFC 5545. \cite{rfc:5545} Meanwhile it is supported by many applications which work with events of any kind. iCalendar is the defacto standard in this field. Hence it has great compatibility with many programs.  The standard defines the MIME type \texttt{text/calendar}. So iCalendar is mostly used for exchanging calendaring data, like sending invitations, and for providing public calendaring data, the timetable of the football world championship for example.

\subsection{iCalendar format}

\begin{lstlisting}[aboveskip=1\baselineskip, style=bash, caption=iCalendar example., label=listing024]
BEGIN:VCALENDAR
CALSCALE:GREGORIAN (*@ \label{line017} @*)
METHOD:PUBLISH
PRODID:iCalendar-Ruby
VERSION:2.0
BEGIN:VTIMEZONE (*@ \label{line018} @*)
TZID:Europe/Berlin
BEGIN:STANDARD
DTSTART:19960811T073001
RRULE:FREQ=DAILY;INTERVAL=2
TZNAME:UTC+01:00
TZOFFSETFROM:+0200
TZOFFSETTO:+0100
END:STANDARD
END:VTIMEZONE
BEGIN:VEVENT (*@ \label{line019} @*)
CATEGORIES:FAMILY
DESCRIPTION:4ffa4c76e75c29032a88ed19
DTEND;TZID=Europe/Berlin:20120804T170000
DTSTAMP:20120829T184941
DTSTART;TZID=Europe/Berlin:20120804T170000
SEQUENCE:1
SUMMARY:Ob-La-Di\, Ob-La-DaAAAA
TRANSP:TRANSPARENT
UID:2012-08-29T18:49:41+02:00_158310425@u-081-c222.eap.uni-tuebingen.de
URL:https://trello.com/card/ob-la-di-ob-la-daaaaa/4ffa4c5ce75c29032a88ea31/2
END:VEVENT
\end{lstlisting}

Listing \ref{listing024} shows an example of a file in the iCalendar format this script can produce. The top-level element of an iCalendar file is the core object. The first line is \lstinline{BEGIN:VCALENDAR} and the ending line has to be \lstinline{END:VCALENDAR}. Between these two tags is the \emph{icalbody}. Following are the iCalendar properties. These properties apply to the entire calendar. \lstinline{CALSCALE:GREGORIAN} in line \ref{line017} of listing \ref{listing024} defines the calendar scale of this calendar. Hence the standard calendar format is Gregorian world wide it'n not neccessary to specify it in the iCalendar file. The method specification can has other values than \lstinline{PUBLISH}, such like \lstinline{REQUEST} and \lstinline{CANCEL}. \lstinline{REQUEST} would be used if the sender wants to know if the receiver is free at the time of this event. \lstinline{CANCEL} would be used when the provided events in this calendar should be cancelled. The \lstinline{PRODID} simply specifies the product which generated the iCalendar file. The \lstinline{VERSION} property specifies the version that is required in order to interpret the iCalendar file. Version 2.0 is the last version. In line \ref{line018} the definition of the timezone starts. \lstinline{TZID} specifies the identifier of this time zone. \lstinline{TZOFFSETFROM} and \lstinline{TZOFFSETTO} specify both the offset to UTC. \lstinline{TZOFFSETFROM} for daylight saving time and \lstinline{TZOFFSETTO} for standard time. \lstinline{DTSTART} in this context describes the first onset date-time for the observance. The \lstinline{RRULE} property defines a repeating pattern for recurring events. \lstinline{TZNAME} is just a name for the specified timezone. In \ref{line019} the definition of the actual event begins. Every single event is specified within an \lstinline{VEVENT} object. The \lstinline{VEVENT} objects are listed after each other. There is the possibility to divide the events into categories with the \lstinline{CATEGORIES} property. The \lstinline{DESCRIPTION} contains a description string of the event. Here the script enters the id of the respective card. \lstinline{DTSTART} and \lstinline{DTEND} specify the starting and ending times of the event. The \lstinline{DTSTAMP} property contains the time of the export to iCalenar format. \lstinline{SUMMARY} is the events title. The \lstinline{SEQUENCE} is teh revision counter of an event object. If the user makes significant changes to the event, the \lstinline{SEQUENCE} must be incremented. When the event object is created the \lstinline{SEQUENCE} is  zero. \lstinline{TRANSP} determines whether the event object consumes time on a calendar or not. Events that consume time with the calendar should have the \lstinline{TRANSP} value \lstinline{OPAQUE}. Events which are marked as \lstinline{OPAQUE} can be detected as consuming time by free/busy time searches on the calendar. If events don't consume actual time on the calendar they should be marked as \lstinline{TRANSPARENT}. Here the script gives all events an \lstinline{TRANSP} value of \lstinline{TRANSPARENT} because the due date of a Trello card is not an actual appointment with a duration. It's more like a deadline for a particular task. The \lstinline{UID} countains information abaout the creator of the iCalendar data. In this case it's a time and the name of my computer in the network of Uni Tübingen. Finally the \lstinline{URL} property contains simply the URL of the card at Trello. With this URL the user can visit the card from within his calendaring application. So he can visit and edit the card without navigation through Trello by himself. \cite{ical:specs}

This is just a subset of the iCalendar geared to use with the \texttt{ical.rb} script. iCalendar supports much more. For example, to-do lists, recurring events, journals, searching for free/busy time and updating calendars. These features wouldn't be useful with the intented use with Trello. 

\subsection{Export}

After the \texttt{ical.rb} script got all necessary information calculated by the API wrapper, a new \lstinline{VCALENDAR} object must be generated. Of course is possible to write own methods to generate a valid iCalendar code. But there is a sophisticated Ruby gem that covers all needede features. This gem is simply called \emph{icalendar}\footnote{The icalendar gem's GitHub repository: \url{https://github.com/sdague/icalendar}}.

\begin{lstlisting}[aboveskip=1\baselineskip, caption=Generating a new \lstinline{VCALENDAR}., label=listing027]
cal = Calendar.new

cal.timezone do
	timezone_id             "Europe/Berlin"
	
	standard do (*@ \label{line020} @*)
		timezone_offset_from  "+0200"
		timezone_offset_to    "+0100"
		timezone_name         "UTC+01:00"
		dtstart               "19960811T073001"
		add_recurrence_rule   "FREQ=DAILY;INTERVAL=2"
	end
end
\end{lstlisting}

Listing \ref{listing027} generates the iCalendar file in listing \ref{listing024} until line \ref{line019}. The \lstinline{timezone} method creates a new \lstinline{VTIMEZONE} object. In line \ref{line020} the \lstinline{BEGIN:STANDARD} is generated and fillied in the following lines. The methods used to add the properties ​​are not exactly self-explanatory. Therefore it is recommended to read the documentation carefully.

\begin{lstlisting}[aboveskip=1\baselineskip, style=bash, caption=Generating the \lstinline{VEVENT} object., label=listing027]
cardsFull.each do |card|
	if card['due'] != nil	
		
		cal.event do (*@ \label{line021} @*)
			dtstart       getDate(card['due'], 'ical') (*@ \label{line022} @*)
			dtend         getDate(card['due'], 'ical') (*@ \label{line023} @*)
			summary     	card['name']
			description 	card['id']
			transp				"TRANSPARENT"
			categories		["FAMILY"]
			sequence			0
			url						card['url']
		end		
	end
end
\end{lstlisting}

In listing \ref{listing027} the iCalendar code for every event is created. The array \lstinline{cardsFull} contains all cards which sould be checked if they have a due date. The source code block starting at line \ref{021} must be executed for every card with a due date in Trello. In line \ref{line022} and \ref{line023} the \lstinline{getDate} method is used. It computes the date in the correct format for iCalendar. If that's done the iCalendar object is created. 

\begin{lstlisting}[aboveskip=1\baselineskip, style=bash, caption=Saving the iCalendar file., label=listing027]
cal.publish (*@ \label{line024} @*)

icalendar = File.new("icalendar.ics", "w+")
icalendar.puts cal.to_ical (*@ \label{line025} @*)
icalendar.close()
\end{lstlisting}

The last step is to write the generated iCalendar objet to a file. In line \ref{line024} of listing \ref{listing027} the \lstinline{publish} method publishes the iCalendar object. This is an important step. It ensures that later in the iCalendar file the \lstinline{METHOD} property is set to \lstinline{PUBLISH}. In line \ref{line025} the \lstinline{to_ical} method converts the Calendar object instantiated in the first line of listing \ref{listing027} to  a string in iCalendar format. This string is saved to a file which is named \lstinline{icalendar.ics}. \cite{ical:gemdocu}

Now the \lstinline{icalendar.ics} file can be sent in an email or uploaded to a web server. No matter on which way this file is distributed, if there's a software which is able to handle the iCalendar format, everybody can read it.

The iCalendar format has a field for attendees. If this is specified everyone can see who's invited to this event. But unfortunately it cann't be used with this script because the Trello API doesn't provide a method to get a users email adress. That's for privacy reasons, for sure, but it would be great if there were such an option. Maybe only for private boards though.

\subsection{Comparison to the Google Calendar synchronisation} 

In comparison to the Google synchronisation, the script is much more simple. There is no need for synchronization because the iCalendar file is regenerated with each run of the script and there is no API to work with. There is only one file in the correct format to be created. That's much faster than working with two APIs and perform several API calls. The server has to compute less data and there's less traffic to the APIs while updating. But of course the iCalendar file must be available on a server. With the Google solution there is no need for an own web server. The another bigger problem with the webserver is, that the URL is accesible for everybody. If the calendar includes critical data this is a disqualifier for the user or the company. Although it is possible to provide the server with password protection, this would only be more complicated. Either the calendaring software doesn't support .htaccess or any other web authentication technology orthe user has to enter his login information periodically. The only way to use it safely with critical data is to use it in an intranet. There won't be any need for additional protcetion. But for the domestic use and for most small companies the solution with Google  should be sufficient. Google even provides an iCalendar feed itself. 

\section{Synchronisation to Joomla}\index{Joomla}

Used libraries:
\begin{itemize}
	\item \texttt{icalendar}
	\item \texttt{date}
	\item \texttt{json}
	\item \texttt{rest\_client}
	\item \texttt{pp}
	\item \texttt{kramdown}
\end{itemize}

Usage:
\begin{lstlisting}[aboveskip=1\baselineskip, style=bash, caption=\texttt{joomlaMultiple.rb} usage., label=listing028]
ruby joomlaMultiple.rb --section SECTIONID --category CATEGORYID [-c CARDID[,CARDID]] [-l LISTID[,LISTID]] [-b BOARDID[,BOARDID]] [-a] [-t TOKEN] [-k KEY]
\end{lstlisting}

Trello is perfect to depict recurring structures. Blog posts, for example, have such a structure which is repeated for each post. Each post has a title, a text, a creation date, an author, etc. The script \texttt{joomlaMultiple.rb} posts a card in Trello to the Joomla CMS.

Joomla\footnote{Joomla project website: \url{http://www.joomla.org}} is one of the most popular CMS \nomenclature{CMS}{Content Management System} overall. It's open source and free of cost. Joomla is written in object oriented PHP \cite{joomla:architecture} and uses software design patterns. \cite{joomla:mvc} Joomla is the result of a fork of the older CMS Mambo\footnote{The Mambo foundations website: \url{http://mambo-foundation.org}} from the year 2005. Mambo exists since 2000.

The Joomla CMS doesn't have an API for the here needed purposes. It's built on top of the Joomla \emph{Platform} (formerly known as Joomla \emph{Framework}). That's a framework which provides classes and methods to build a web application on top of it – such as Joomla. Since 2011 the Joomla Platformis distributed seperately from the CMS. This makes it easier for developers to use the Joomla Platform for web applications which are not a CMS. \cite{joomla:api} But because there is no API, developers have to access the underlying database to add content to Joomla.

This script has additionally to the standard set of command-line arguments two special arguments. The \texttt{--section} argument defines a section in Joomla under which the article should be listed. The \texttt{--category} means the same for Joomla categories. Sections in Joomla are the top content structure. Every category is related to a section. Articles in Joomla are related to a section and a category.

\begin{lstlisting}[aboveskip=1\baselineskip, caption=Passing the needed information to the trelloJoomlaSync() method., label=listing028]
sectionid = options.section.first
catid = options.category.first

cardsToImport.each do |card| (*@ \label{line024}@*)
	trelloJoomlaSync(card['id'], sectionid, catid, '1.5')
end
\end{lstlisting}

The \texttt{joomlaMultiple.rb} script gets its data from the API wrapper. The first two line of listing \ref{listing028} read the section and category id from the command-line arguments. The API wrapper provides a method to accomplish the synchronisation of a Trello card to Joomla. Thus the \texttt{joomlaMultiple.rb} script has just to pass this function an id of the card which should be synchronised. In line \ref{line024} the script traverses the array with the cards to import to Joomla. The next line calls the \lstinline{trelloJoomlaSync()} method for every card. It just passes the card id, the section id and the category id and the Joomla version which is used. Everything else is handled by the \lstinline{trelloJoomlaSync()} method.

\begin{lstlisting}[aboveskip=1\baselineskip, caption=Getting standard card information., label=listing029]
card = getSingleCard(cardId)
title = card['name']  (*@ \label{line025}@*)
description = Kramdown::Document.new(card['desc']).to_html  (*@ \label{line026}@*)
\end{lstlisting}

\lstinline{trelloJoomlaSync()} must determine a cards whole information itself. The \lstinline{getSingleCard()} supplies the standard information of a card such as the title in line \ref{line025} of listing \ref{listing029} and the description in line \ref{line026}. Again, the \texttt{kramdown}gem is used to convert the Markdown\index{Markdown} formatted description string to HTML\index{HTML}. But attachments and checklists would also be meaningful to depict in a CMS\index{CMS}. Besides, the cards creation or update date is required to decide whether a card has changed or not.

\begin{lstlisting}[aboveskip=1\baselineskip, caption=Getting the date of a cards last change., label=listing030]
changed = nil
if !cardUpdated(cardId).empty?
	changed = getDate(cardUpdated(cardId).first['date'], 'joomla')
else
	changed = getDate(cardCreated(cardId).first['date'], 'joomla')
end
\end{lstlisting}
There is an API call for the last update of a card. But if the card has never been updated the response would be empty. So in this case the API call for the creation date must be used.

\begin{lstlisting}[aboveskip=1\baselineskip, caption=Processing the attachments of a card., label=listing031]
hasAttachment = getAttachment(cardId) (*@ \label{line027}@*)

if hasAttachment[0] != nil
	description += "<ul>"		
	hasAttachment.each do |att|	
		description += "<li><a href=\""+att['url']+"\">\""+att['name']+"\"</a></li>"
	end
	description += "</ul>"
end
\end{lstlisting}

To get the attachments of a card the \lstinline{getAttachment(cardId)} method is used in line \ref{line027} of listing \ref{listing031}. If the API call contains attachment data the HTML tag \lstinline{<ul>} is appended to the description. After that the attachments are appended as list items. Their names are simply linked with the URL to the file on Trellos servers.  

\begin{lstlisting}[aboveskip=1\baselineskip, caption=Processing the checklists of a card., label=listing032]
hasChecklist = getChecklist(cardId) 

if hasChecklist[0] != nil
	hasChecklist.each do |checklist| 			
		description += "<h4>"+checklist['name']+"</h4>"
		description += "<ul>"
		checklist['checkItems'].each do |item|	
			if isCompleted(cardId, item['id'])
				description += "<li><del>"+item['name']+"</del></li>"
			else
				description += "<li>"+item['name']+"</li>"
			end
		end
		description += "</ul>"
	end	
end
\end{lstlisting}

To process the checklists of a card the method \lstinline{getChecklist(cardId)} is called first. If the response contains checklist data a \lstinline{<h4>} HTML tag with the checklists name is added to the description. After that a \lstinline{<ul>} is started again. For every checklist item the \lstinline{isCompleted()} method must be called to resolve the determine of the checklist item. Depending on that the name of the item is displayed as crossed out or not. Rubys append method is used because the description is a HTML string already.

Now that the content is available to the script, it must be written to the database. Because the \lstinline{trelloJoomlaSync()} method supports Joomla versions 1.5 and 2.5, every database query is existing twice. From Joomla 1.5 to Joomla 2.5 the underlying database structury has changed a bit. 

\begin{lstlisting}[aboveskip=1\baselineskip, caption=\texttt{joomlaMultiple.rb} usage., label=listing033]
begin  
	existingArticleQuery = my.query(" (*@ \label{line028}@*)
		SELECT id, created, modified
		FROM jos_content 
		WHERE metadata='"+cardId+"'
	") (*@ \label{line029}@*)
rescue Mysql::Error => e
	puts e
else
	# if article doesn't exist insert it into the db
	if existingArticleQuery.num_rows == 0
		begin
			
			# Insert new article, see listing (*@ \ref{listing034} @*)(*@ \label{line030}@*)
			
		rescue Mysql::Error => e
			puts e
			return
		ensure
			stmt.close if stmt
		end			
	else
		# this should be only one because per Trello card id should only exist one article in Joomla
		existingArticleQuery.each do |thisArticle|
			
			existingId = thisArticle[0]
			existingCreated = thisArticle[1]
			existingModified = thisArticle[2]
			
			# check if the modiefied timestamp im Trello is different to the modiefied timestamp in Joomla
			begin 
				if existingModified != changed
					
					# Update article, see listing (*@ \ref{listing036} @*)(*@ \label{line032}@*)
					
					puts 'Changed: '+cardId+" : "+title
				else 
					puts 'Nothing changed: '+cardId+" : "+title
				end					
			rescue Mysql::Error => e
				puts e
				return
			ensure
				stmt.close if stmt
			end
		end
	end	
ensure
	my.close if my
end
\end{lstlisting}

In the first \lstinline{begin} block of listing \ref{listing033} from line \ref{line028} to line \ref{line029} the method searches the database table \lstinline{jos_content} after an article with the actual handled cardId in the \lstinline{metadata} field. If the response of this query is an empty array, the card isn't in the database. So the script must insert a new article into the database. Thats performed in line \ref{line030}. The corresponsing MySQL code is showed in listing \ref{listing034}. If the resulting array in line \ref{line028} contains a row, the script must check if the new data is newer as the data in the database. This array can not contain more than one row, because the script inserts the article just once if it's new, otherwise it replaces the old article with an updated version. In order to do that the script looks at the \lstinline{modified} field of the existing article. This date is saved in the \lstinline{existingModified} variable. The update date of the actual Trello card, that is determined in listing \ref{listing030}, is stored in the \lstinline{changed} variable. If \lstinline{existingModified} differs from \lstinline{changed} the article is updated with the new date of the Trello card in line \ref{line032}. In this behaviour the script assumes that the Trello card contains always the correct data. So it's not necessary to check back if the \lstinline{changed} is actual newer. The MySQL statemnt of the update statemnt is showed in listing \ref{listing036}.

\begin{lstlisting}[aboveskip=1\baselineskip, caption=Insert new article in the Joomla database., label=listing034]
begin
	stmt = my.prepare("
		INSERT INTO jos_content (
			title, 
			alias, 
			`introtext`, 
			state, 
			sectionid, 
			catid, 
			created, 
			created_by, 
			modified,
			parentid, 
			ordering, 
			access,					
			metadata
		)
		VALUES (
			?, 
			?, 
			?, 
			1, 
			?, 
			?, 
			?, 
			62, 
			?,
			0, 
			1, 
			0,
			?
		)
	")
	
	stmt.execute title, title.downcase, description.gsub((*@/'/@*), '&(*@\#@*)39;'), sectionid, catid, changed, changed, cardId
	puts 'New article: '+cardId+" : "+title
rescue Mysql::Error => e
	puts e
	return
ensure
	stmt.close if stmt
end
\end{lstlisting}


\begin{lstlisting}[aboveskip=1\baselineskip, caption=Updating existing Joomla article., label=listing036]
stmt = my.prepare("
	UPDATE jos_content 
	SET
		title = '"+title+"',
		alias = '"+title.downcase+"',
		`introtext` = '"+description.gsub(/'/, '&#39;')+"',
		state = 1,
		sectionid = 5,
		catid = 34,
		created = '"+changed+"',
		created_by = 62,
		modified = '"+changed+"',
		parentid = 0,
		ordering = 1,
		access = 0
	WHERE
		metadata = '"+cardId+"'
")
stmt.execute
\end{lstlisting}

\subsection{Joomla category page}

After the cards from Trello are imported to Joomla as articles they are saved in Joomla, but not necessarily accessible on the web site. To view the articles on one page Joomla provides the item type \emph{Category Blog Layout}. This is a menu object type. The user must specify a category when executing the script. All the articles which are assigned to this category will be displayed on a atomatically created web page. If the user wants to display all the imported articles from Trello on one page he have to create such an category blog layout for the category he specified. The user can customize the appearence of the site.

\subsection{Single article}
Sometimes it makes more sense if all the cards are stored as a single article in Joomla. The \texttt{joomlaSingle.rb} does that. This script works exclusively with Joomla version 1.5. This verion of Joomla uses still HTML tables for structuring the websites. So the script generates a special HTML site of all cars, similar to the \texttt{html.rb} script described in section \ref{html.rb}.

%\section{One way synchronisation to WordPress}\index{WordPress}

%\todo{What's WordPress?}

%\todo{Why WordPress? -> Exorbitant popularity!}

\section{Backup}\index{Backup}

Trello doesn't provide a complete backup solution. Single cards can be downloaded as *.json files, but that's not worth colling it a backup solution. It might be usefull to have the possibility to access the whole sight of a users Trello account offline. For example to use it in a dedicated Trello application or another project dedicated software. Anyhow the user is on the safe side if he backs his Trello boards up.

\subsection{Export}\index{Export}
Usage:
\begin{lstlisting}[aboveskip=1\baselineskip, style=bash, caption=\texttt{export.rb} usage., label=listing037]
ruby export.rb -n filename -t TOKEN -k KEY
\end{lstlisting}

The \texttt{-n} command-line property specifies the filename which is used to store the exported data from Trello.

The \texttt{export.rb} script at first has to accumulate the data. Unlike the other scripts the whole information is needed all at once and in the most compact structure. So, there are four big types of content: boards, lists, cards and members. The method \lstinline(getBoardsByMember('me')) determines the boards of the member. \lstinline{getMembersByBoard()} determines the members by board, means, this is an array which contains the boards as hashes. One value of these hashes contains all members that are assigned to this board. For each board \lstinline{getListsByBoard()} determines the related lists. The cards are collected by board as well with the \lstinline{getCardsByBoard} method. But because these API response contains not the whole information about a card the card array must be extended with the \lstinline{getCardsAsArray()} method. This method also downloads attachments, if any.  When all the data of these four content types is avalable, each array is saved to a mutual hash:

\begin{lstlisting}[aboveskip=1\baselineskip, caption=\texttt{joomlaMultiple.rb} usage., label=listing038]
hashBackup = Hash.new
hashBackup['boards'] = arrayBoards
hashBackup['members'] = arrayMembersByBoards
hashBackup['lists'] = arrayLists
hashBackup['cards'] = arrayCards
\end{lstlisting}

\lstinline{hashBackup} contains the whole data of a users Trello account. Now it have to be saved to the backup file. 

\subsubsection{Saving to JSON files}
The JSON library for Ruby described in section \ref{jsonsec} is able to generate JSON out of Ruby hashes and arrays.

\begin{lstlisting}[aboveskip=1\baselineskip, caption=Using the temporary directory of the operating system to save the JSON to file., label=listing039]
backupFile = File.new(File.join(Dir.tmpdir, 'backup.json'), "wb") (*@ \label{line033} @*)
backupFile.puts JSON.generate(hashBackup)
backupFile.close()
\end{lstlisting}

In line \ref{line033} of listing \ref{listing039} a file called \texttt{backup.json} is opened. \lstinline{Dir.tmpdir} determines the path to the temporary directory of the operating system. This works under every operating system Ruby supports. Using the temporary directory has several advantages. Even if the saving process is cancelled it wouldn't result in a cluttered directory. The temporary directory is cleaned by the operating system regularly. The \lstinline{join} method of Rubys \lstinline{File} class merges the path of the temporary directory and the file name to a correct path to a file in the temporary directory. \lstinline{File.new} makes this new file accesible with the variable \lstinline{backupFile}. To store the generated hash in the file the script first generates the JSON with the \lstinline{generate} method of the JSON library. The result is directly stored in the \texttt{backup.json} file because the \lstinline{puts} method applied to the \lstinline{backupFile} variable accesses the file in the temporary directory. The last step closes the \texttt{backup.json} file.

Now there is one JSON file and a directory with attachments. For exchanging the data this combination is not practical. A single file is needed. In order to achive that and to minimise file size the script uses the gem \texttt{zippy}. \texttt{zippy} is used to easily generate ZIP archives. 

\begin{lstlisting}[aboveskip=1\baselineskip, caption=Creating a ZIP archive out of the backed up data., label=listing040]
Zippy.create @filename do |zip|
	zip['backup.json'] = File.open(backupFile) (*@ \label{line034} @*)

	Dir.entries(directoryNameAttachments).each do |file| (*@ \label{line035} @*)
		fileName = File.new(File.join(directoryNameAttachments, file), "r") 
		if file != "." && file != ".."
			zip['attachments/'+file] = File.open(fileName)
			fileName.close
			File.delete(fileName)
		end
	end
end
\end{lstlisting}

In order to create a single ZIP file \texttt{zippy} opens a \lstinline{create} block. To add a file to the ZIP archive it can be specified like in an array. In  line \ref{line034} of listing \ref{listing040} a new file with the name \texttt{backup.json} in the ZIP archive is created. In the same step it is filled with the contents of the \lstinline{backupFile} variable, which is basicly the \texttt{backup.json} in the temporary directory. In line \ref{line035} the script iterates through attachment directory in the temporary directory. Each attachment is stored in an \texttt{attachments} directory in the ZIP archive. After that the attachments are deleted from the temporary directory. Unless the operating system will delete them anyway if they are not in use, the attachments directory and the \texttt{backup.json} file are also deleted.




\subsection{Import}\index{Import}

Usage:
\begin{lstlisting}[aboveskip=1\baselineskip, style=bash, caption=\texttt{import.rb} usage., label=listing041]
ruby import.rb -n filename -t TOKEN -k KEY
\end{lstlisting}

In contrast to the \texttt{export.rb} script, with the \texttt{-n} the user can specify a file to import. At first the scipt checks if the file is a ZIP\index{ZIP} file. For this it doesn't use the file name but the MIME\nomenclature{MIME}{Multipurpose Internet Mail Extensions}\index{MIME} type of the file.

\begin{lstlisting}[aboveskip=1\baselineskip, caption=Checking if the file has the MIME type \textquotedblleft application/zip\textquotedblright, label=listing008]
if `file -Ib #{@filename}`.gsub(/;.*\n/, "") != "application/zip"
	puts "ERROR: The backup\index{Backup} file has to be a ZIP\index{ZIP} file!"
	abort
end
\end{lstlisting}

	
In line 1 the \texttt{file -Ib \#\{\@filename\}} is a bash call for receiving the MIME\index{MIME} type of a file. Ruby executes it and with the gsub-Method it cuts the MIME part out of the received string. This shell script part in a ruby file is a bit messy. But only for this small case it would be complicated to use a separate gem.

\todo{What's a MIME\index{MIME} type?}

\todo{Problem adding members}

\todo{Import problems with comments, votes, subscriptions.}

\subsection{Member import}

\todo{Solution with memberimport.rb.}

\subsection{Close all boards}
\texttt{closeboards.rb} is more of a helper tool for developers. Do you mean: While developing Trello, several test accounts emerge which now and then get crowded with test boards. The execution of this script will close all boards in the specified Trello account. The CLI isn't employed here because it would be too dangerous. If the wrong account was accitently indicated all the boards would go.

